

### System Overview
1. **Smart Contract (Solidity)**: Handles deposits, withdrawals, and Merkle tree updates for commitments.
2. **Circom Circuits**: Generate zero-knowledge proofs for anonymous withdrawals, ensuring the commitment is in the Merkle tree without revealing it.
3. **Client-Side Logic**: Allows users to interact with the mixer (deposit, generate proofs, withdraw).
4. **Server-Side Logic**: A simple off-chain service to store and provide Merkle tree data and proofs (for educational simplicity).
5. **Merkle Tree**: Stores commitment hashes, enabling efficient proof of inclusion.

### Assumptions and Simplifications
- Fixed deposit amount: 0.1 ETH.
- Uses Poseidon hash 
- Merkle tree with a fixed depth i.e 2^20 commitments.
- Uses Semaphore-style zero-knowledge proofs for withdrawal.
- No relayer or gas abstraction for simplicity.
- Client-side handles proof generation; server provides Merkle tree data.

### Step-by-Step Implementation

#### 1. Smart Contract (Solidity)
The smart contract manages deposits and withdrawals, storing commitment hashes in a Merkle tree and verifying zk-proofs.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/MerkleTree.sol";
import "./Verifier.sol";

contract Mixer {
    uint256 public constant DEPOSIT_AMOUNT = 0.1 ether;
    uint32 public constant TREE_DEPTH = 20;

    // Merkle tree root
    bytes32 public merkleRoot;
    // Array to store all commitment hashes
    bytes32[] public commitments;
    // Mapping to prevent double-spending
    mapping(bytes32 => bool) public nullifierUsed;

    // Verifier contract for zk-proofs
    Verifier public verifier;

    event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);
    event Withdrawal(address to, bytes32 nullifierHash);

    constructor(address verifierAddress) {
        verifier = Verifier(verifierAddress);
        // Initialize Merkle tree with a zero leaf
        commitments.push(bytes32(0));
        merkleRoot = bytes32(0);
    }

    // Deposit 0.1 ETH and add commitment to Merkle tree
    function deposit(bytes32 commitment) external payable {
        require(msg.value == DEPOSIT_AMOUNT, "Incorrect deposit amount");
        require(commitments.length < 2**TREE_DEPTH, "Tree is full");

        // Add commitment to the tree
        uint32 leafIndex = uint32(commitments.length);
        commitments.push(commitment);

        // Update Merkle root (simplified for demo; use incremental updates in production)
        bytes32[] memory leaves = new bytes32[](commitments.length);
        for (uint256 i = 0; i < commitments.length; i++) {
            leaves[i] = commitments[i];
        }
        merkleRoot = MerkleTree.getRoot(leaves);

        emit Deposit(commitment, leafIndex, block.timestamp);
    }

    // Withdraw using zk-proof
    function withdraw(
        bytes32 nullifierHash,
        bytes32 root,
        address recipient,
        uint256[8] calldata proof
    ) external {
        require(!nullifierUsed[nullifierHash], "Nullifier already used");
        require(root == merkleRoot, "Invalid Merkle root");

        // Verify zk-proof
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [uint256(root), uint256(nullifierHash), uint256(uint160(recipient))]
            ),
            "Invalid proof"
        );

        // Mark nullifier as used
        nullifierUsed[nullifierHash] = true;

        // Send 0.1 ETH to recipient
        (bool success, ) = recipient.call{value: DEPOSIT_AMOUNT}("");
        require(success, "Transfer failed");

        emit Withdrawal(recipient, nullifierHash);
    }

    // Get the current number of commitments
    function getCommitmentCount() external view returns (uint256) {
        return commitments.length;
    }
}
```

**Notes**:
- The contract uses a simplified Merkle tree update for educational clarity. In production, use incremental updates for gas efficiency.
- The `Verifier.sol` contract is generated by Circom and deployed separately to verify zk-proofs.
- `DEPOSIT_AMOUNT` is hardcoded to 0.1 ETH.
- `nullifierUsed` prevents double-spending by tracking used nullifiers.

#### 2. Circom Circuits
The Circom circuit proves that a userâ€™s commitment is in the Merkle tree and generates a nullifier to prevent double-spending, without revealing the commitment. We use Poseidon hash for zk-friendly hashing and a Merkle tree inclusion proof.

```circom
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/mimc.circom";
include "../node_modules/circomlib/circuits/merkleTree.circom";

// Circuit to prove a commitment is in the Merkle tree and generate a nullifier
template Mixer(levels) {
    // Public inputs
    signal input root;
    signal input nullifierHash;
    signal input recipient;

    // Private inputs
    signal input secret;
    signal input nullifier;
    signal input pathElements[levels];
    signal input pathIndices[levels];

    // Compute commitment
    component commitmentHasher = Poseidon(2);
    commitmentHasher.inputs[0] <== secret;
    commitmentHasher.inputs[1] <== nullifier;
    signal commitment;
    commitment <== commitmentHasher.out;

    // Verify Merkle tree inclusion
    component tree = MerkleTreeChecker(levels);
    tree.leaf <== commitment;
    tree.root <== root;
    for (var i = 0; i < levels; i++) {
        tree.pathElements[i] <== pathElements[i];
        tree.pathIndices[i] <== pathIndices[i];
    }

    // Compute nullifier hash
    component nullifierHasher = Poseidon(1);
    nullifierHasher.inputs[0] <== nullifier;
    nullifierHash === nullifierHasher.out;

    // Ensure recipient is a valid Ethereum address (constraint for safety)
    signal recipientSquared;
    recipientSquared <== recipient * recipient;
}

// Instantiate circuit with 20 levels
component main {public [root, nullifierHash, recipient]} = Mixer(20);
```

**Detailed Explanation of Circuit**:
- **Inputs**:
  - **Public**: `root` (Merkle tree root), `nullifierHash`, `recipient` (withdrawal address).
  - **Private**: `secret` (random value), `nullifier` (unique per withdrawal), `pathElements` and `pathIndices` (Merkle proof).
- **Commitment**: Computed as `Poseidon(secret, nullifier)`. This is the leaf in the Merkle tree.
- **Merkle Tree Inclusion**:
  - The `MerkleTreeChecker` component from `circomlib` verifies that the commitment is a leaf in the tree.
  - `pathElements` are sibling nodes along the path to the root.
  - `pathIndices` indicate whether the leaf is the left or right child at each level (0 for left, 1 for right).
  - The circuit recomputes the root using the commitment and path, ensuring it matches the public `root`.
- **Nullifier Hash**: Computed as `Poseidon(nullifier)` to prevent double-spending.
- **Constraints**: Ensures the computed commitment is in the tree and the nullifier hash matches the public input.
- **Poseidon Hash**: Used for its efficiency in zk-SNARKs compared to MiMC or SHA256.
- **Tree Depth**: Set to 20, allowing 2^20 (~1 million) commitments.

**Merkle Tree Details**:
- **Structure**: A binary tree where leaves are commitment hashes (`Poseidon(secret, nullifier)`).
- **Height**: 20 levels, so the tree can store up to 2^20 leaves.
- **Hash Function**: Poseidon is used at each level to compute parent nodes.
- **Inclusion Proof**: For a leaf at index `i`:
  - Compute the path by traversing to the root, collecting sibling nodes.
  - `pathIndices` is the binary representation of `i` (LSB first).
  - For example, for leaf index 3 (binary 11):
    - Level 0: `pathIndices[0] = 1` (right child), sibling is leaf 2.
    - Level 1: `pathIndices[1] = 1` (right child), sibling is hash of leaves 0 and 1.
  - The circuit recomputes the root using the leaf, `pathElements`, and `pathIndices`.
- **Storage**: The smart contract stores all leaves and recomputes the root. In production, use an incremental Merkle tree for efficiency.

**Compilation**:
- Compile the circuit using Circom: `circom mixer.circom --r1cs --wasm --sym`.
- Generate the verifier contract using `snarkjs`.
- Deploy the verifier contract and link it to `Mixer.sol`.

#### 3. Client-Side Logic
The client is a web app using JavaScript, Web3.js, and Circom-generated WASM for proof generation. Users deposit, generate proofs, and withdraw.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Mixer</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="mixer_js/mixer.wasm.js"></script> <!-- Circom-generated WASM -->
</head>
<body>
    <h1>Crypto Mixer (Educational)</h1>
    <button onclick="deposit()">Deposit 0.1 ETH</button>
    <button onclick="withdraw()">Withdraw</button>
    <script>
        const contractAddress = "0x..."; // Deployed Mixer.sol address
        const verifierAddress = "0x..."; // Deployed Verifier.sol address
        const abi = [/* Mixer.sol ABI */];
        let web3, contract, accounts;

        async function init() {
            if (window.ethereum) {
                web3 = new Web3(window.ethereum);
                accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                contract = new web3.eth.Contract(abi, contractAddress);
            }
        }

        async function deposit() {
            const secret = web3.utils.randomHex(32);
            const nullifier = web3.utils.randomHex(32);
            // Compute commitment using Poseidon (via server or local lib)
            const commitment = await computePoseidon(secret, nullifier);
            await contract.methods.deposit(commitment).send({
                from: accounts[0],
                value: web3.utils.toWei("0.1", "ether")
            });
            // Store secret, nullifier locally (e.g., localStorage for demo)
            localStorage.setItem('secret', secret);
            localStorage.setItem('nullifier', nullifier);
            alert("Deposit successful!");
        }

        async function withdraw() {
            const secret = localStorage.getItem('secret');
            const nullifier = localStorage.getItem('nullifier');
            const recipient = accounts[0];
            // Fetch Merkle proof from server
            const { root, pathElements, pathIndices, leafIndex } = await fetchMerkleProof(commitment);
            // Generate zk-proof
            const proof = await generateProof(secret, nullifier, pathElements, pathIndices, root, recipient);
            const nullifierHash = await computePoseidon(nullifier);
            // Withdraw
            await contract.methods.withdraw(nullifierHash, root, recipient, proof).send({ from: accounts[0] });
            alert("Withdrawal successful!");
        }

        async function computePoseidon(...inputs) {
            // In practice, use a Poseidon JS library or server call
            return "0x..."; // Placeholder
        }

        async function fetchMerkleProof(commitment) {
            // Fetch from server
            const response = await fetch(`/merkle-proof?commitment=${commitment}`);
            return await response.json();
        }

        async function generateProof(secret, nullifier, pathElements, pathIndices, root, recipient) {
            // Use Circom-generated WASM
            const input = {
                secret, nullifier, root, recipient,
                pathElements, pathIndices,
                nullifierHash: await computePoseidon(nullifier)
            };
            const { proof } = await snarkjs.groth16.fullProve(input, "mixer.wasm", "mixer.zkey");
            return [proof.pi_a[0], proof.pi_a[1], proof.pi_b[0][1], proof.pi_b[0][0], 
                    proof.pi_b[1][1], proof.pi_b[1][0], proof.pi_c[0], proof.pi_c[1]];
        }

        init();
    </script>
</body>
</html>
```

**Notes**:
- Users connect via MetaMask.
- `computePoseidon` is a placeholder; use a Poseidon JS library or server call.
- Proof generation uses Circomâ€™s WASM output and `snarkjs`.
- Merkle proof is fetched from the server.
- Secret and nullifier are stored in `localStorage` for simplicity (not secure; use encrypted storage in practice).

#### 4. Server-Side Logic
The server provides Merkle tree data and proofs. For simplicity, itâ€™s a Node.js app using Express.

```javascript
const express = require('express');
const { MerkleTree } = require('merkletreejs');
const { poseidon } = require('circomlibjs');
const app = express();

const leaves = [Buffer.alloc(32)]; // Initialize with zero leaf
const tree = new MerkleTree(leaves, poseidon, { hashLeaves: false });

app.use(express.json());

// Add a new commitment
app.post('/deposit', (req, res) => {
    const { commitment } = req.body;
    leaves.push(Buffer.from(commitment.slice(2), 'hex'));
    tree = new MerkleTree(leaves, poseidon, { hashLeaves: false });
    res.json({ leafIndex: leaves.length - 1 });
});

// Get Merkle proof for a commitment
app.get('/merkle-proof', (req, res) => {
    const { commitment } = req.query;
    const leaf = Buffer.from(commitment.slice(2), 'hex');
    const leafIndex = leaves.findIndex(l => l.equals(leaf));
    if (leafIndex === -1) return res.status(404).json({ error: 'Commitment not found' });
    
    const proof = tree.getProof(leafIndex);
    const pathElements = proof.map(p => '0x' + p.data.toString('hex'));
    const pathIndices = tree.getProofPath(leafIndex).map(p => p ? 1 : 0);
    const root = '0x' + tree.getRoot().toString('hex');
    
    res.json({ root, pathElements, pathIndices, leafIndex });
});

app.listen(3000, () => console.log('Server running on port 3000'));
```

**Notes**:
- Uses `merkletreejs` and `circomlibjs` for Merkle tree and Poseidon hashing.
- Stores commitments in memory (use a database in production).
- Provides Merkle proofs for clients to generate zk-proofs.

### Setup Instructions (Educational)
1. **Smart Contract**:
   - Deploy `Verifier.sol` (generated by Circom).
   - Deploy `Mixer.sol` with the verifier address.
2. **Circom**:
   - Install Circom and `snarkjs`.
   - Compile `mixer.circom` and generate WASM and zkey.
   - Export the verifier contract.
3. **Server**:
   - Install Node.js, Express, `merkletreejs`, and `circomlibjs`.
   - Run `node server.js`.
4. **Client**:
   - Host `index.html` or run locally.
   - Ensure `mixer.wasm` and `mixer.zkey` are in the correct directory.
   - Connect to an Ethereum testnet (e.g., Sepolia) via MetaMask.

### Security Considerations (Educational)
- **Privacy**: The zk-proof ensures no link between deposit and withdrawal.
- **Double-Spending**: Nullifiers prevent reusing commitments.
- **Gas Costs**: Incremental Merkle tree updates would reduce gas costs.
- **Storage**: Store secrets securely (not in `localStorage`).
- **Audit**: In production, audit the smart contract and circuit for vulnerabilities.

This implementation mimics Tornado Cashâ€™s core functionality for educational purposes, with detailed Circom circuits and Merkle tree logic. Let me know if you need further clarification or additional components!
