

### System Overview
1. **Smart Contract (Solidity)**: Handles deposits, withdrawals, and Merkle tree updates for commitments.
2. **Circom Circuits**: Generate zero-knowledge proofs for anonymous withdrawals, ensuring the commitment is in the Merkle tree without revealing it.
3. **Client-Side Logic**: Allows users to interact with the mixer (deposit, generate proofs, withdraw).
4. **Server-Side Logic**: A simple off-chain service to store and provide Merkle tree data and proofs (for educational simplicity).
5. **Merkle Tree**: Stores commitment hashes, enabling efficient proof of inclusion.

### Assumptions and Simplifications
- Fixed deposit amount: 0.1 ETH.
- Uses Poseidon hash 
- Merkle tree with a fixed depth i.e 2^20 commitments.
- Uses Semaphore-style zero-knowledge proofs for withdrawal.
- No relayer or gas abstraction for simplicity.
- Client-side handles proof generation; server provides Merkle tree data.

### Step-by-Step Implementation

#### 1. Smart Contract (Solidity)
The smart contract manages deposits and withdrawals, storing commitment hashes in a Merkle tree and verifying zk-proofs.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/MerkleTree.sol";
import "./Verifier.sol";

contract Mixer {
    uint256 public constant DEPOSIT_AMOUNT = 0.1 ether;
    uint32 public constant TREE_DEPTH = 20;

    // Merkle tree root
    bytes32 public merkleRoot;
    // Array to store all commitment hashes
    bytes32[] public commitments;
    // Mapping to prevent double-spending
    mapping(bytes32 => bool) public nullifierUsed;

    // Verifier contract for zk-proofs
    Verifier public verifier;

    event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);
    event Withdrawal(address to, bytes32 nullifierHash);

    constructor(address verifierAddress) {
        verifier = Verifier(verifierAddress);
        // Initialize Merkle tree with a zero leaf
        commitments.push(bytes32(0));
        merkleRoot = bytes32(0);
    }

    // Deposit 0.1 ETH and add commitment to Merkle tree
    function deposit(bytes32 commitment) external payable {
        require(msg.value == DEPOSIT_AMOUNT, "Incorrect deposit amount");
        require(commitments.length < 2**TREE_DEPTH, "Tree is full");

        // Add commitment to the tree
        uint32 leafIndex = uint32(commitments.length);
        commitments.push(commitment);

        // Update Merkle root (simplified for demo; use incremental updates in production)
        bytes32[] memory leaves = new bytes32[](commitments.length);
        for (uint256 i = 0; i < commitments.length; i++) {
            leaves[i] = commitments[i];
        }
        merkleRoot = MerkleTree.getRoot(leaves);

        emit Deposit(commitment, leafIndex, block.timestamp);
    }

    // Withdraw using zk-proof
    function withdraw(
        bytes32 nullifierHash,
        bytes32 root,
        address recipient,
        uint256[8] calldata proof
    ) external {
        require(!nullifierUsed[nullifierHash], "Nullifier already used");
        require(root == merkleRoot, "Invalid Merkle root");

        // Verify zk-proof
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [uint256(root), uint256(nullifierHash), uint256(uint160(recipient))]
            ),
            "Invalid proof"
        );

        // Mark nullifier as used
        nullifierUsed[nullifierHash] = true;

        // Send 0.1 ETH to recipient
        (bool success, ) = recipient.call{value: DEPOSIT_AMOUNT}("");
        require(success, "Transfer failed");

        emit Withdrawal(recipient, nullifierHash);
    }

    // Get the current number of commitments
    function getCommitmentCount() external view returns (uint256) {
        return commitments.length;
    }
}
```

**Notes**:
- The contract uses a simplified Merkle tree update for educational clarity. In production, use incremental updates for gas efficiency.
- The `Verifier.sol` contract is generated by Circom and deployed separately to verify zk-proofs.
- `DEPOSIT_AMOUNT` is hardcoded to 0.1 ETH.
- `nullifierUsed` prevents double-spending by tracking used nullifiers.

#### 2. Circom Circuits
The Circom circuit proves that a user’s commitment is in the Merkle tree and generates a nullifier to prevent double-spending, without revealing the commitment. We use Poseidon hash for zk-friendly hashing and a Merkle tree inclusion proof.

```circom
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/mimc.circom";
include "../node_modules/circomlib/circuits/merkleTree.circom";

// Circuit to prove a commitment is in the Merkle tree and generate a nullifier
template Mixer(levels) {
    // Public inputs
    signal input root;
    signal input nullifierHash;
    signal input recipient;

    // Private inputs
    signal input secret;
    signal input nullifier;
    signal input pathElements[levels];
    signal input pathIndices[levels];

    // Compute commitment
    component commitmentHasher = Poseidon(2);
    commitmentHasher.inputs[0] <== secret;
    commitmentHasher.inputs[1] <== nullifier;
    signal commitment;
    commitment <== commitmentHasher.out;

    // Verify Merkle tree inclusion
    component tree = MerkleTreeChecker(levels);
    tree.leaf <== commitment;
    tree.root <== root;
    for (var i = 0; i < levels; i++) {
        tree.pathElements[i] <== pathElements[i];
        tree.pathIndices[i] <== pathIndices[i];
    }

    // Compute nullifier hash
    component nullifierHasher = Poseidon(1);
    nullifierHasher.inputs[0] <== nullifier;
    nullifierHash === nullifierHasher.out;

    // Ensure recipient is a valid Ethereum address (constraint for safety)
    signal recipientSquared;
    recipientSquared <== recipient * recipient;
}

// Instantiate circuit with 20 levels
component main {public [root, nullifierHash, recipient]} = Mixer(20);
```

**Detailed Explanation of Circuit**:
- **Inputs**:
  - **Public**: `root` (Merkle tree root), `nullifierHash`, `recipient` (withdrawal address).
  - **Private**: `secret` (random value), `nullifier` (unique per withdrawal), `pathElements` and `pathIndices` (Merkle proof).
- **Commitment**: Computed as `Poseidon(secret, nullifier)`. This is the leaf in the Merkle tree.
- **Merkle Tree Inclusion**:
  - The `MerkleTreeChecker` component from `circomlib` verifies that the commitment is a leaf in the tree.
  - `pathElements` are sibling nodes along the path to the root.
  - `pathIndices` indicate whether the leaf is the left or right child at each level (0 for left, 1 for right).
  - The circuit recomputes the root using the commitment and path, ensuring it matches the public `root`.
- **Nullifier Hash**: Computed as `Poseidon(nullifier)` to prevent double-spending.
- **Constraints**: Ensures the computed commitment is in the tree and the nullifier hash matches the public input.
- **Poseidon Hash**: Used for its efficiency in zk-SNARKs compared to MiMC or SHA256.
- **Tree Depth**: Set to 20, allowing 2^20 (~1 million) commitments.

**Merkle Tree Details**:
- **Structure**: A binary tree where leaves are commitment hashes (`Poseidon(secret, nullifier)`).
- **Height**: 20 levels, so the tree can store up to 2^20 leaves.
- **Hash Function**: Poseidon is used at each level to compute parent nodes.
- **Inclusion Proof**: For a leaf at index `i`:
  - Compute the path by traversing to the root, collecting sibling nodes.
  - `pathIndices` is the binary representation of `i` (LSB first).
  - For example, for leaf index 3 (binary 11):
    - Level 0: `pathIndices[0] = 1` (right child), sibling is leaf 2.
    - Level 1: `pathIndices[1] = 1` (right child), sibling is hash of leaves 0 and 1.
  - The circuit recomputes the root using the leaf, `pathElements`, and `pathIndices`.
- **Storage**: The smart contract stores all leaves and recomputes the root. In production, use an incremental Merkle tree for efficiency.

**Compilation**:
- Compile the circuit using Circom: `circom mixer.circom --r1cs --wasm --sym`.
- Generate the verifier contract using `snarkjs`.
- Deploy the verifier contract and link it to `Mixer.sol`.

#### 3. Client-Side Logic
The client is a web app using JavaScript, Web3.js, and Circom-generated WASM for proof generation. Users deposit, generate proofs, and withdraw.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Mixer</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="mixer_js/mixer.wasm.js"></script> <!-- Circom-generated WASM -->
</head>
<body>
    <h1>Crypto Mixer (Educational)</h1>
    <button onclick="deposit()">Deposit 0.1 ETH</button>
    <button onclick="withdraw()">Withdraw</button>
    <script>
        const contractAddress = "0x..."; // Deployed Mixer.sol address
        const verifierAddress = "0x..."; // Deployed Verifier.sol address
        const abi = [/* Mixer.sol ABI */];
        let web3, contract, accounts;

        async function init() {
            if (window.ethereum) {
                web3 = new Web3(window.ethereum);
                accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                contract = new web3.eth.Contract(abi, contractAddress);
            }
        }

        async function deposit() {
            const secret = web3.utils.randomHex(32);
            const nullifier = web3.utils.randomHex(32);
            // Compute commitment using Poseidon (via server or local lib)
            const commitment = await computePoseidon(secret, nullifier);
            await contract.methods.deposit(commitment).send({
                from: accounts[0],
                value: web3.utils.toWei("0.1", "ether")
            });
            // Store secret, nullifier locally (e.g., localStorage for demo)
            localStorage.setItem('secret', secret);
            localStorage.setItem('nullifier', nullifier);
            alert("Deposit successful!");
        }

        async function withdraw() {
            const secret = localStorage.getItem('secret');
            const nullifier = localStorage.getItem('nullifier');
            const recipient = accounts[0];
            // Fetch Merkle proof from server
            const { root, pathElements, pathIndices, leafIndex } = await fetchMerkleProof(commitment);
            // Generate zk-proof
            const proof = await generateProof(secret, nullifier, pathElements, pathIndices, root, recipient);
            const nullifierHash = await computePoseidon(nullifier);
            // Withdraw
            await contract.methods.withdraw(nullifierHash, root, recipient, proof).send({ from: accounts[0] });
            alert("Withdrawal successful!");
        }

        async function computePoseidon(...inputs) {
            // In practice, use a Poseidon JS library or server call
            return "0x..."; // Placeholder
        }

        async function fetchMerkleProof(commitment) {
            // Fetch from server
            const response = await fetch(`/merkle-proof?commitment=${commitment}`);
            return await response.json();
        }

        async function generateProof(secret, nullifier, pathElements, pathIndices, root, recipient) {
            // Use Circom-generated WASM
            const input = {
                secret, nullifier, root, recipient,
                pathElements, pathIndices,
                nullifierHash: await computePoseidon(nullifier)
            };
            const { proof } = await snarkjs.groth16.fullProve(input, "mixer.wasm", "mixer.zkey");
            return [proof.pi_a[0], proof.pi_a[1], proof.pi_b[0][1], proof.pi_b[0][0], 
                    proof.pi_b[1][1], proof.pi_b[1][0], proof.pi_c[0], proof.pi_c[1]];
        }

        init();
    </script>
</body>
</html>
```

**Notes**:
- Users connect via MetaMask.
- `computePoseidon` is a placeholder; use a Poseidon JS library or server call.
- Proof generation uses Circom’s WASM output and `snarkjs`.
- Merkle proof is fetched from the server.
- Secret and nullifier are stored in `localStorage` for simplicity (not secure; use encrypted storage in practice).

#### 4. Server-Side Logic
The server provides Merkle tree data and proofs. For simplicity, it’s a Node.js app using Express.

```javascript
const express = require('express');
const { MerkleTree } = require('merkletreejs');
const { poseidon } = require('circomlibjs');
const app = express();

const leaves = [Buffer.alloc(32)]; // Initialize with zero leaf
const tree = new MerkleTree(leaves, poseidon, { hashLeaves: false });

app.use(express.json());

// Add a new commitment
app.post('/deposit', (req, res) => {
    const { commitment } = req.body;
    leaves.push(Buffer.from(commitment.slice(2), 'hex'));
    tree = new MerkleTree(leaves, poseidon, { hashLeaves: false });
    res.json({ leafIndex: leaves.length - 1 });
});

// Get Merkle proof for a commitment
app.get('/merkle-proof', (req, res) => {
    const { commitment } = req.query;
    const leaf = Buffer.from(commitment.slice(2), 'hex');
    const leafIndex = leaves.findIndex(l => l.equals(leaf));
    if (leafIndex === -1) return res.status(404).json({ error: 'Commitment not found' });
    
    const proof = tree.getProof(leafIndex);
    const pathElements = proof.map(p => '0x' + p.data.toString('hex'));
    const pathIndices = tree.getProofPath(leafIndex).map(p => p ? 1 : 0);
    const root = '0x' + tree.getRoot().toString('hex');
    
    res.json({ root, pathElements, pathIndices, leafIndex });
});

app.listen(3000, () => console.log('Server running on port 3000'));
```

**Notes**:
- Uses `merkletreejs` and `circomlibjs` for Merkle tree and Poseidon hashing.
- Stores commitments in memory (use a database in production).
- Provides Merkle proofs for clients to generate zk-proofs.

### Setup Instructions (Educational)
1. **Smart Contract**:
   - Deploy `Verifier.sol` (generated by Circom).
   - Deploy `Mixer.sol` with the verifier address.
2. **Circom**:
   - Install Circom and `snarkjs`.
   - Compile `mixer.circom` and generate WASM and zkey.
   - Export the verifier contract.
3. **Server**:
   - Install Node.js, Express, `merkletreejs`, and `circomlibjs`.
   - Run `node server.js`.
4. **Client**:
   - Host `index.html` or run locally.
   - Ensure `mixer.wasm` and `mixer.zkey` are in the correct directory.
   - Connect to an Ethereum testnet (e.g., Sepolia) via MetaMask.

### Security Considerations (Educational)
- **Privacy**: The zk-proof ensures no link between deposit and withdrawal.
- **Double-Spending**: Nullifiers prevent reusing commitments.
- **Gas Costs**: Incremental Merkle tree updates would reduce gas costs.
- **Storage**: Store secrets securely (not in `localStorage`).
- **Audit**: In production, audit the smart contract and circuit for vulnerabilities.

This implementation mimics Tornado Cash’s core functionality for educational purposes, with detailed Circom circuits and Merkle tree logic. Let me know if you need further clarification or additional components!
