<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Mixer</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="https://unpkg.com/snarkjs@latest/build/snarkjs.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/circomlibjs@latest/dist/circomlibjs.bundle.js"></script>

    <script src="./mixer_js/mixer.wasm.js"></script>  <!-- Circom-generated WASM -->

    <script src="./mixer_js/mixer_final.zkey.js"></script> <!-- Circom-generated ZKey -->

    <script src="https://cdn.jsdelivr.net/npm/merkletreejs@latest/index.min.js"></script>
</head>
<body>
    <h1>Crypto Mixer (Educational)</h1>
    <button onclick="deposit()">Deposit 0.1 ETH</button>
    <button onclick="withdraw()">Withdraw</button>
    <script>
        const contractAddress = "0x..."; // Deployed Mixer.sol address
        const verifierAddress = "0x..."; // Deployed Verifier.sol address
        const abi = [/* Mixer.sol ABI */];
        let web3, contract, accounts;

        async function init() {
            if (window.ethereum) {
                web3 = new Web3(window.ethereum);
                try {
                    accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                    contract = new web3.eth.Contract(abi, contractAddress);
                    mixerWASM = await fetch("./mixer_js/mixer.wasm").then(response => response.arrayBuffer());
                    mixerZKEY = JSON.parse(mixer_final_zkey);
                    document.getElementById("status").innerText = "Web3 initialized. Connected account: " + accounts;
                } catch (error) {
                    document.getElementById("status").innerText = "Error connecting to MetaMask: " + error.message;
                }
            } else {
                document.getElementById("status").innerText = "MetaMask not detected.";
            }
        }

        async function deposit() {
            if (!contract) {
                document.getElementById("status").innerText = "Contract not initialized.";
                return;
            }
            const secret = circomlibjs.babyJub.randomScalar();
            const nullifier = circomlibjs.babyJub.randomScalar();
            const commitmentInput = [secret, nullifier];
            const commitment = circomlibjs.poseidon(commitmentInput);
            const commitmentHex = web3.utils.padLeft(web3.utils.toHex(commitment), 64);

            try {
                document.getElementById("status").innerText = "Depositing...";
                await contract.methods.deposit(commitmentHex).send({
                    from: accounts,
                    value: web3.utils.toWei("0.1", "ether")
                });
                
                // Store secret and nullifier locally
                localStorage.setItem('secret', secret.toString());
                localStorage.setItem('nullifier', nullifier.toString());
                localStorage.setItem('commitment', commitment.toString());
                document.getElementById("status").innerText = "Deposit successful! Commitment: " + commitment.toString();
            } catch (error) {
                document.getElementById("status").innerText = "Deposit failed: " + error.message;
            }
        }

        async function withdraw() {
            if (!contract) {
                document.getElementById("status").innerText = "Contract not initialized.";
                return;
            }
            const secret = localStorage.getItem('secret');
            const nullifier = localStorage.getItem('nullifier');
            const commitment = localStorage.getItem('commitment');
            const recipient = accounts;

            if (!secret ||!nullifier ||!commitment) {
                document.getElementById("status").innerText = "Secret, nullifier, or commitment not found. Please make a deposit first.";
                return;
            }

            document.getElementById("status").innerText = "Generating Merkle proof...";
            const commitmentHex = web3.utils.padLeft(web3.utils.toHex(commitment), 64);

            try {
                const commitmentCount = await contract.methods.getCommitmentCount().call();
                const currentCommitments = [];
                for (let i = 0; i < commitmentCount; i++) {
                    currentCommitments.push(await contract.methods.getCommitment(i).call());
                }

                const leaves = currentCommitments.map(c => Buffer.from(c.slice(2), 'hex'));
                const tree = new MerkleTree(leaves, circomlibjs.poseidon, { hashLeaves: false });
                const leaf = Buffer.from(commitmentHex.slice(2), 'hex');
                const leafIndex = leaves.findIndex(l => l.equals(leaf));

                if (leafIndex === -1) {
                    document.getElementById("status").innerText = "Commitment not found in the Merkle tree.";
                    return;
                }

                const proof = tree.getProof(leafIndex);
                const pathElements = proof.map(p => '0x' + Buffer.from(p.data).toString('hex'));
                const pathIndices = tree.getProofPath(leafIndex).map(p => p? 1 : 0);
                const root = '0x' + tree.getRoot().toString('hex');

                document.getElementById("status").innerText = "Generating zk-proof...";
                const nullifierHashInput = [nullifier];
                const nullifierHash = circomlibjs.poseidon(nullifierHashInput);
                const nullifierHashHex = web3.utils.padLeft(web3.utils.toHex(nullifierHash), 64);
                const rootHex = root;
                const recipientDecimal = web3.utils.toBN(recipient).toString();

                const input = {
                    secret: secret,
                    nullifier: nullifier,
                    pathElements: pathElements,
                    pathIndices: pathIndices,
                    root: root,
                    nullifierHash: nullifierHash,
                    recipient: recipientDecimal
                };

                const proofData = await snarkjs.groth16.fullProve(input, mixerWASM, mixerZKEY);
                const solidityProof = [
                    proofData.proof.pi_a,
                    proofData.proof.pi_a[2],
                    proofData.proof.pi_b[2],
                    proofData.proof.pi_b,
                    proofData.proof.pi_b[2][2],
                    proofData.proof.pi_b[2],
                    proofData.proof.pi_c,
                    proofData.proof.pi_c[2]];

                document.getElementById("status").innerText = "Withdrawing...";
                await contract.methods.withdraw(nullifierHashHex, rootHex, recipient, solidityProof).send({ from: accounts });
                localStorage.removeItem('secret');
                localStorage.removeItem('nullifier');
                localStorage.removeItem('commitment');
                document.getElementById("status").innerText = "Withdrawal successful!";

            } catch (error) {
                document.getElementById("status").innerText = "Withdrawal failed: " + error.message;
            }
        }

        init();
    </script>
</body>
</html>